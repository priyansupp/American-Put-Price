# -*- coding: utf-8 -*-
"""MA374_ExtraAssignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n5lU02W6lCEo1aBvjadbG9KH9qRytMIK
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
import math
import random
import seaborn as sns
 
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.layers import Dropout

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from sklearn.metrics import accuracy_score

from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.statespace.sarimax import SARIMAX

import plotly
import plotly.graph_objs as go
import plotly.express as px
from plotly.subplots import make_subplots

data = yf.download('ORCL', start="2022-04-29", end="2023-04-29") 
data

data.columns

corrMatrix = data.corr()
plt.figure(figsize = (8, 5))
sns.heatmap(corrMatrix, annot=True)
plt.show()

sd = seasonal_decompose(data['Close'], period = 125 ) 
fig = sd.plot()
plt.rcParams['figure.figsize'] = [8.0, 5.0]

df = pd.DataFrame()
df['Date'] = data.index
df['Date'] = pd.to_datetime(df['Date'], infer_datetime_format = True)
df['Close'] = data.iloc[: , 3].to_numpy()

data1 = df['Close'].copy()
df

df.info()

d1 = df.filter(['Close'])
d1 = d1.values
scaler = MinMaxScaler()
d1 = scaler.fit_transform(d1)

d2 = d1[ : len(d1) - 50, 0] 
d2.shape

x_train = []
y_train = []
for i in range(25, len(d2)) :
      x_train.append(d2[i - 25 : i] )
      y_train.append(d2[i])

x_train = np.array(x_train)
y_train = np.array(y_train)

x_train = np.reshape(x_train, (x_train.shape[0], x_train.shape[1], 1) )

# LSTM
model = Sequential()

model.add(LSTM(16, activation = 'relu', input_shape=(x_train.shape[1], 1), return_sequences = True) )

model.add(Dropout(0.1))

model.add(LSTM(8, activation = 'relu', return_sequences = False ) )

model.add(Dropout(0.1))

model.add(Dense(1000, activation = 'relu') )

model.add(Dense(1))

model.compile(optimizer='adam', loss='mse', metrics=['accuracy'])

model.summary()

d3 = d1[len(d1) - 50 : , 0]
d3.shape

x_test = []
y_test = []
for i in range(25, len(d3)) :
  x_test.append(d3[i - 25 : i] )
      
y_test = df.iloc[len(df) - 25 : , 1]

x_test = np.array(x_test)
y_test = np.array(y_test)

print(x_test.shape)
x_test = np.reshape(x_test, (x_test.shape[0], x_test.shape[1], 1) )

model.fit(x_train, y_train, epochs = 25)

y_train.shape

pred = model.predict(x_test) 
pred.shape

pred = scaler.inverse_transform(pred)

tp = np.linspace(0,25,25)
tp1 = np.linspace(0,25,25)

plt.plot(tp, pred)
plt.plot(tp1, y_test)
plt.legend(['LSTM', 'Original'])
plt.show()

print(math.sqrt(mean_squared_error(y_test, pred)) )

# SARIMAX
data3 = df['Close'] 
    
# Split data into train and test set (90% - train, 10% - test)
train3_data, test3_data = data3[3 : int(len(data3) * 0.9)], data3[int(len(data3) * 0.9) : ] 

# test_values = len(data3) * 0.01 + 1.0 
x_train = list(range(0, 224))
x_test = list(range(224, int(len(data3))))

exo_data = data['Volume']
exo_data = exo_data[int(len(exo_data) * 0.9):]

stock_name = 'ORCL' 

fig = go.Figure()
fig.add_trace(go.Scatter(x=x_train, y=train3_data, mode='lines+markers', marker=dict(size=4),  name='train', marker_color='#39304A'))
fig.add_trace(go.Scatter(x=x_test, y=test3_data, mode='lines+markers', marker=dict(size=4), name='test', marker_color='#A98D75'))
fig.update_layout(legend_orientation="h",
                  legend=dict(x = 0.5, xanchor = "center"),
                  plot_bgcolor='#FFFFFF',  
                  xaxis=dict(gridcolor = 'lightgrey'),
                  yaxis=dict(gridcolor = 'lightgrey'),
                  title_text = f'{stock_name} SARIMAX data', title_x = 0.5, 
                  xaxis_title="Timestep",
                  yaxis_title="Stock price",
                  margin=dict(l=0, r=0, t=30, b=0))
# fig.show()
    
model = SARIMAX(train3_data, order=(3, 1, 2))

arima_model = model.fit(X = exo_data, disp=-1)

print(arima_model.summary())


preds3 = arima_model.predict(n_periods=22, alpha=0.05)

preds3 = np.vstack(preds3)
preds3 = preds3[-22:]
hist_data = yf.download(stock_name, start="2021-04-01", end="2021-05-04")
hist_data = hist_data.drop(['Open', 'High', 'Low', 'Adj Close', 'Volume'], axis=1)
hist_data = hist_data['Close']
hist_data = np.array(hist_data)
    
rmse = np.sqrt(np.mean(((preds3 - hist_data) ** 2)))
print(f'RMSE SARIMAX: {rmse}')
    
preds_gr = np.reshape(preds3, (22,))
fig = go.Figure()
fig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers', name='historical', marker_color='#39304A'))
fig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))
fig.update_layout(legend_orientation="h",
                  legend=dict(x=.5, xanchor="center"),
                  plot_bgcolor='#FFFFFF',  
                  xaxis=dict(gridcolor = 'lightgrey'),
                  yaxis=dict(gridcolor = 'lightgrey'),
                  title_text = f'{stock_name} SARIMAX prediction', title_x = 0.5,
                  xaxis_title="Timestep",
                  yaxis_title="Stock price",
                  margin=dict(l=0, r=0, t=30, b=0))
# fig.show()

tp = np.linspace(0,len(preds_gr),len(preds_gr))
tp1 = np.linspace(0,len(preds_gr),len(preds_gr))

plt.plot(tp, preds_gr)
plt.plot(tp1, hist_data)
plt.legend(['SARIMAX', 'Original'])
plt.show()

# GBM
data_f= yf.download('ORCL', start="2022-04-29", end="2023-04-29") 
df1 = data_f['Close']

n = 25
dt = 1.0/n

df2 = df1.pct_change()

mu = np.mean(df2)
sigma = np.std(df2) * math.sqrt(252)


S0 = df1.iloc[-1]
Wt = np.random.normal(0, 1, n)

S = []
S.append(S0)

for i in range(n-1):
    St = S0 * math.exp( (mu - sigma**2)*dt + sigma*math.sqrt(dt)*Wt[i])
    S.append(St)
    S0 = St

print(St) 
print(mu)
print(sigma)
data1

tp = np.linspace(0,len(S),len(S))
tp1 = np.linspace(0,len(S),len(S))

plt.plot(tp, S)
plt.plot(tp1, y_test)
plt.legend(['GBM', 'Original'])
plt.show()

print(math.sqrt(mean_squared_error(y_test, pred)) )

t1 = np.linspace(0,25,25)
t2 = np.linspace(0,22,22)


plt.plot(t1, y_test)
plt.plot(t1, pred)
plt.plot(t2, preds_gr)
plt.plot(t1, S)

plt.legend(['Original Data', 'LSTM Predicted', 'SARIMAX', 'GBM'])
plt.show()

!python -m pip install -U git+https://github.com/coin-or/pulp

import pulp as plp

a1 = yf.download('ORCL', start="2022-04-29", end="2023-04-29") 

b1 = a1['Close']
b1 = np.array(b1)

final_pred = []
final_mse = []

wt_lstm = 0.4
wt_gbm = 0.3
wt_sarimax = 0.3


model = plp.LpProblem('Optimal_weights', plp.LpMinimize)

wt_lstm = plp.LpVariable("weight_lstm", lowBound = 0, upBound=0.6)
wt_gbm = plp.LpVariable("weight_mcmc", lowBound = 0, upBound=0.6)
wt_sarimax = plp.LpVariable("weight_arima", lowBound = 0, upBound=0.6)

for i in range(20):
    final_pred.append(pred[i]*wt_lstm + S[i]*wt_gbm + preds_gr[i]*wt_sarimax)
    
for i in range (20):
    final_mse.append(b1[i] - final_pred[i])

final_mse = np.mean(final_mse)
sum_w = wt_lstm + wt_gbm + wt_sarimax 

model += final_mse
model += sum_w <= 1.0
model += sum_w >= 1.0

plp.LpSolverDefault.msg = 1


model.solve()
print('model solve')
status = model.solve()
print("Model status: ", plp.LpStatus[status])
print(model)

wt_lstm_f = wt_lstm.varValue
wt_gbm_f = wt_gbm.varValue
wt_sarimax_f = wt_sarimax.varValue


fpred = []

for i in range(20):
    fpred.append(pred[i]*wt_lstm_f + S[i]*wt_gbm_f + preds_gr[i]*wt_sarimax_f)

fpred = np.vstack(fpred)    



preds_gr = np.reshape(fpred, (20,))
fig = go.Figure()
fig.add_trace(go.Scatter(x=list(range(0, 21)), y=hist_data, mode='lines+markers',  name='historical', marker_color='#39304A'))
fig.add_trace(go.Scatter(x=list(range(0, 21)), y=preds_gr, mode='lines+markers', name='predictions', marker_color='#FFAA00'))
fig.update_layout(legend_orientation="h",
                legend=dict(x=.5, xanchor="center"),
                plot_bgcolor='#FFFFFF',  
                xaxis=dict(gridcolor = 'lightgrey'),
                yaxis=dict(gridcolor = 'lightgrey'), 
                title_text = f'{stock_name} final prediction', title_x = 0.5,
                xaxis_title="Timestep",
                yaxis_title="Stock price",
                margin=dict(l=0, r=0, t=30, b=0))
# fig.show()
tp = np.linspace(0,len(preds_gr),len(preds_gr))
tp1 = np.linspace(0,len(preds_gr),len(preds_gr))

plt.plot(tp, preds_gr)
plt.plot(tp1, y_test[:len(preds_gr)])
plt.legend(['Model', 'Original'])
plt.show()

# print(math.sqrt(mean_squared_error(y_test, pred)) )


mse1 = []
for i in range (20):
    mse1.append(abs(b1[i] - fpred[i]))
mse1 = np.mean(mse1)
rmse = math.sqrt(mse1)

print(f'RMSE = {rmse}')
print(f'LSTM weight: {wt_lstm_f}')
print(f'GBM weight: {wt_gbm_f}')
print(f'SARIMAX weight: {wt_sarimax_f}')

# American Put Option

z1 = df.iloc[226 : , 1]
z1 = z1.to_numpy()

S0 = z1[0]
ind = 0

for i in range(len(z1)) :
    if z1[i] < S0 :
       S0 = z1[i]
       ind = i

options = yf.Ticker("ORCL").option_chain("2023-05-05")
Kmean = options.puts.strike.mean()/0.9

print("Mean Strike Price for Oracle: ", Kmean)

r = 3.54

Put_Price = math.exp(-r*(ind/252.0))*max(Kmean - S0 , 0)
print("American Put Option Price", Put_Price)
